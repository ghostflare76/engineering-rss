<!DOCTYPE html><html lang="ko"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>클라우드플레어가 인터넷 규모 TCP 연결 특성을 측정한 방법</title>    <link rel="preconnect" href="https://fonts.googleapis.com">    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>    <link href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600;9..144,700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">    <style>        @import url("https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable-dynamic-subset.min.css");                * {            margin: 0;            padding: 0;            box-sizing: border-box;        }                body {            font-family: "Pretendard Variable", -apple-system, BlinkMacSystemFont, system-ui, sans-serif;            background: #faf8f5;            color: #2d2d2d;            line-height: 1.7;            padding: 20px;            font-size: 16px;        }                .container {            max-width: 850px;            margin: 0 auto;            background: #ffffff;            border-radius: 16px;            overflow: hidden;            box-shadow: 0 4px 20px rgba(201, 69, 31, 0.08);            animation: fade-in 0.6s ease;        }                @keyframes fade-in {            from {                opacity: 0;                transform: translateY(20px);            }            to {                opacity: 1;                transform: translateY(0);            }        }                .header {            background: linear-gradient(135deg, #E5734F 0%, #C9451F 100%);            padding: 48px 40px;            color: #ffffff;        }                .header-label {            font-family: 'JetBrains Mono', monospace;            font-size: 13px;            letter-spacing: 1.5px;            opacity: 0.9;            margin-bottom: 12px;            text-transform: uppercase;        }                .header h1 {            font-family: 'Fraunces', serif;            font-size: 36px;            font-weight: 700;            line-height: 1.3;            margin-bottom: 16px;        }                .header-meta {            font-size: 14px;            opacity: 0.85;            font-weight: 500;        }                .content {            padding: 48px 40px;        }                .intro {            font-size: 18px;            line-height: 1.8;            color: #3d3d3d;            margin-bottom: 40px;            padding-bottom: 32px;            border-bottom: 2px solid #f0ebe5;            animation: fade-slide-up 0.6s ease 0.2s both;        }                .intro p {            margin-bottom: 16px;        }                .intro p:last-child {            margin-bottom: 0;        }                .intro strong {            color: #C9451F;            font-weight: 600;        }                .intro ul {            list-style: none;            padding-left: 0;            margin: 20px 0;        }                .intro ul li {            padding-left: 28px;            margin-bottom: 10px;            position: relative;            line-height: 1.7;        }                .intro ul li::before {            content: "•";            position: absolute;            left: 0;            color: #C9451F;            font-weight: 600;            font-size: 20px;        }                @keyframes fade-slide-up {            from {                opacity: 0;                transform: translateY(20px);            }            to {                opacity: 1;                transform: translateY(0);            }        }                .section {            margin-bottom: 40px;            animation: fade-slide-up 0.6s ease both;        }                .section:nth-child(2) { animation-delay: 0.3s; }        .section:nth-child(3) { animation-delay: 0.4s; }        .section:nth-child(4) { animation-delay: 0.5s; }        .section:nth-child(5) { animation-delay: 0.6s; }        .section:nth-child(6) { animation-delay: 0.7s; }                .section-title {            font-family: 'Fraunces', serif;            font-size: 24px;            font-weight: 700;            color: #C9451F;            margin-bottom: 20px;            display: flex;            align-items: center;            gap: 12px;        }                .section-emoji {            font-size: 28px;        }                .section-content {            font-size: 16px;            line-height: 1.8;            color: #3d3d3d;        }                .section-content p {            margin-bottom: 16px;        }                .section-content p:last-child {            margin-bottom: 0;        }                .highlight-box {            background: #fff9f5;            border-left: 4px solid #C9451F;            padding: 20px 24px;            margin: 20px 0;            border-radius: 0 8px 8px 0;        }                .highlight-box p {            margin-bottom: 12px;            font-size: 15px;        }                .highlight-box p:last-child {            margin-bottom: 0;        }                .highlight-box strong {            color: #C9451F;        }                .code-box {            background: #2d2d2d;            color: #f0ebe5;            padding: 20px 24px;            border-radius: 8px;            font-family: 'JetBrains Mono', monospace;            font-size: 13px;            line-height: 1.6;            margin: 20px 0;            overflow-x: auto;        }                .code-box code {            color: #6dd4c4;        }                .phase-box {            background: #ffffff;            border: 2px solid #C9451F;            padding: 24px;            margin: 20px 0;            border-radius: 12px;        }                .phase-title {            font-family: 'Fraunces', serif;            font-size: 20px;            font-weight: 700;            color: #C9451F;            margin-bottom: 16px;            display: flex;            align-items: center;            gap: 10px;        }                .phase-content {            font-size: 15px;            line-height: 1.7;            color: #3d3d3d;        }                .phase-content p {            margin-bottom: 12px;        }                .phase-content p:last-child {            margin-bottom: 0;        }                .metric-grid {            display: grid;            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));            gap: 16px;            margin: 24px 0;        }                .metric-card {            background: #faf8f5;            padding: 20px;            border-radius: 12px;            border: 1px solid #f0ebe5;            transition: all 0.3s ease;        }                .metric-card:hover {            transform: translateY(-4px);            box-shadow: 0 6px 20px rgba(201, 69, 31, 0.12);        }                .metric-label {            font-family: 'JetBrains Mono', monospace;            font-size: 12px;            color: #8d6e5f;            margin-bottom: 8px;            text-transform: uppercase;            letter-spacing: 0.5px;        }                .metric-value {            font-family: 'Fraunces', serif;            font-size: 28px;            font-weight: 700;            color: #C9451F;            margin-bottom: 8px;        }                .metric-desc {            font-size: 14px;            color: #5d5d5d;            line-height: 1.5;        }                .bullet-list {            list-style: none;            padding-left: 0;            margin: 16px 0;        }                .bullet-list li {            padding-left: 32px;            margin-bottom: 12px;            position: relative;            line-height: 1.7;        }                .bullet-list li::before {            content: "→";            position: absolute;            left: 0;            color: #C9451F;            font-weight: 600;            font-size: 18px;        }                .stage-grid {            display: grid;            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));            gap: 12px;            margin: 24px 0;        }                .stage-card {            background: #fff9f5;            border: 1px solid #C9451F;            padding: 16px;            border-radius: 8px;            text-align: center;        }                .stage-number {            font-family: 'Fraunces', serif;            font-size: 32px;            font-weight: 700;            color: #C9451F;            margin-bottom: 8px;        }                .stage-name {            font-weight: 700;            color: #2d2d2d;            margin-bottom: 8px;            font-size: 14px;        }                .stage-desc {            font-size: 12px;            color: #5d5d5d;            line-height: 1.5;        }                .cta-box {            background: linear-gradient(135deg, #E5734F 0%, #C9451F 100%);            color: #ffffff;            padding: 32px;            border-radius: 12px;            margin-top: 40px;            text-align: center;        }                .cta-box h3 {            font-family: 'Fraunces', serif;            font-size: 22px;            margin-bottom: 16px;        }                .cta-box p {            font-size: 15px;            line-height: 1.7;            opacity: 0.95;            margin-bottom: 20px;        }                .cta-button {            display: inline-block;            background: #ffffff;            color: #C9451F;            padding: 14px 32px;            border-radius: 8px;            text-decoration: none;            font-weight: 600;            font-size: 15px;            transition: all 0.3s ease;        }                .cta-button:hover {            transform: translateY(-2px);            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);        }                .footer {            background: #faf8f5;            padding: 32px 40px;            text-align: center;            font-size: 14px;            color: #8d6e5f;            border-top: 1px solid #f0ebe5;        }                .footer p {            margin-bottom: 8px;        }                .footer a {            color: #C9451F;            text-decoration: none;            font-weight: 600;        }                .footer a:hover {            text-decoration: underline;        }                @media (max-width: 768px) {            body {                padding: 12px;            }                        .header {                padding: 32px 24px;            }                        .header h1 {                font-size: 28px;            }                        .content {                padding: 32px 24px;            }                        .intro {                font-size: 16px;            }                        .section-title {                font-size: 20px;            }                        .metric-grid, .stage-grid {                grid-template-columns: 1fr;            }                        .footer {                padding: 24px;            }        }    </style></head><body>    <div class="container">        <!-- 헤더 -->        <div class="header">            <div class="header-label">Cloudflare Engineering</div>            <h1>클라우드플레어가 인터넷 규모 TCP 연결 특성을 측정한 방법</h1>            <div class="header-meta">패킷 12개, 지속 시간 4.7초 - 인터넷 트래픽의 숨겨진 모습</div>        </div>                <div class="content">            <!-- 도입부 -->            <div class="intro">                <p>인터넷에서 웹 페이지를 로딩하거나, 영상 스트리밍, API 호출을 할 때마다 보이지 않는 곳에서 '연결'이 이뤄집니다. 하지만 이 연결들이 실제 어떻게 작동하는지에 대한 글로벌 데이터는 놀랍도록 부족합니다. 마치 눈을 가리고 운전하는 것과 비슷하죠.</p>                                <p>수십 년간 연구자들은 이 연결의 특성을 탐구해 왔지만, 전 세계 인터넷 규모에서 '얼마나 오래?', '얼마나 많이?', '얼마나 자주?' 같은 질문에 답할 만한 실측 데이터는 거의 없었습니다. 새로운 네트워크 프로토콜을 도입하거나 라우팅 알고리즘을 변경할 때도, 실제 환경에서의 영향 예측이 어려워 배포는 위험천만하고, 시뮬레이션은 현실성이 떨어진다는 고민이 있었거든요.</p>                                <p>그래서 클라우드플레어가 이 고질적인 문제에 직접 나섰습니다. 전 세계 CDN을 통해 확보한 방대한 TCP 연결 데이터를 분석하여, 그동안 베일에 싸여 있던 인터넷 연결의 진짜 모습을 공개합니다. 이 글에서는 다음 내용을 중심으로 클라우드플레어가 밝혀낸 흥미로운 인사이트를 정리해 봅니다.</p>                                <ul>                    <li>네트워크의 '코끼리와 쥐' 현상: 대부분의 연결은 왜 짧고 작은가? - 패킷/바이트 통계 분석</li>                    <li>HTTP/1.X와 HTTP/2, 그리고 클라이언트 유형별 트래픽 패턴 - 요청 수와 연결 지속 시간의 비밀</li>                    <li>클라이언트와 서버 간 데이터 비대칭성의 진실 - 패킷/바이트 송수신 비율로 본 인사이트</li>                    <li>최적의 네트워크 성능을 위한 '길찾기' - Path MTU와 초기 혼잡 윈도우(ICWND) 최적화</li>                    <li>BBR의 혼잡 윈도우는 왜 그렇게 높을까? - BDP(대역폭-지연 곱)와의 비교를 통한 오해 해소</li>                    <li>낡은 10개 패킷 ICWND의 재평가 - 실측 데이터로 30-40% 성능 향상 기회 포착</li>                </ul>            </div>                        <!-- 본문 섹션 1 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">🤔</span>                    왜 연결 특성 파악이 중요할까요?                </h2>                <div class="section-content">                    <p>네트워크를 포함한 모든 시스템에서 변화의 영향을 예측하려면 그 시스템의 행동 특성을 정확히 아는 것이 중요합니다. 새로운 라우팅 알고리즘이나 전송 프로토콜을 도입할 때, 실제 네트워크에 바로 적용하는 건 예상치 못한 문제를 일으킬 수 있어 위험하죠. 그렇다고 시뮬레이션만으로는 현실을 완벽하게 반영하기 어렵고요.</p>                    <p>유용한 시뮬레이션을 만들려면 실제 시스템과 비슷하게 작동하는 '합성 데이터'가 필요합니다. 이 데이터는 현실의 행동을 모방해야 하는데, 그러려면 먼저 실제 데이터의 핵심 특성을 측정하고 이해해야 합니다. 그런데 인터넷 전체의 연결 특성을 대규모로 파악하기는 사실상 불가능에 가까웠습니다. 접근성도 문제고, 방대한 데이터를 처리하는 스케일도 문제였으니까요. 그래서 클라우드플레어가 나섰습니다.</p>                </div>            </div>                        <!-- 본문 섹션 2 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">🔬</span>                    클라우드플레어는 데이터를 어떻게 수집했나?                </h2>                <div class="section-content">                    <p>데이터의 가치는 수집 메커니즘에 달려 있습니다. 클라우드플레어는 다음 원칙을 가지고 TCP 연결 데이터를 수집하고 분석했습니다.</p>                    <div class="highlight-box">                        <p><strong>1. 데이터셋 개요와 범위</strong></p>                        <p>HTTP 1.0, 1.1, 2.0을 통해 클라우드플레어 CDN으로 들어오는 모든 요청의 약 <strong>70%</strong>를 차지하는 TCP 연결을 분석했습니다. 이는 초당 평균 8,400만 건의 HTTP 요청 중 상당 부분을 포함하죠.</p>                    </div>                    <div class="highlight-box">                        <p><strong>2. 균일한 1% 샘플링</strong></p>                        <p>2025년 10월 7일부터 15일까지의 데이터를 개별 클라이언트 대면 서버에서 <strong>균일하게 1% 샘플링</strong>했습니다. 이는 데이터센터 레벨에서 발생할 수 있는 편향을 줄이기 위함입니다.</p>                    </div>                    <div class="highlight-box">                        <p><strong>3. 다양성과 범위</strong></p>                        <p>클라우드플레어의 트래픽은 검색, 소셜 미디어 등 특정 서비스에 집중된 다른 대형 운영사와 달리, 전 세계 고객사의 다양한 웹 애플리케이션과 사용자로 구성됩니다. 따라서 저희가 관찰하는 연결은 광범위한 클라이언트 장치와 애플리케이션 행동을 반영하죠.</p>                    </div>                    <div class="highlight-box">                        <p><strong>4. '유용한 연결'의 정의와 로깅 내용</strong></p>                        <p>리눅스 커널의 <code>TCP_INFO</code> 구조를 통해 소켓 레벨 메타데이터, SNI, 연결 중 발생한 요청 수를 기록했습니다. 특히 공격 완화로 차단되거나, 타임아웃 또는 <code>RST</code> 패킷으로 중단되는 연결을 제외하고, <strong>정상적으로 <code>FIN</code> 패킷으로 종료</strong>되고 <strong>최소 1개의 HTTP 요청이 성공한 연결</strong>만을 '유용한 연결'로 정의했습니다. 흥미롭게도 <code>FIN</code>으로 종료되는 모든 TCP 연결 중 11%는 유휴 상태였거나 HTTP 요청이 없었고요.</p>                    </div>                    <p>이렇게 수집된 데이터는 시간에 따라 변하는 네트워크 트렌드 속에서도 전반적인 대규모 패턴은 놀랍도록 일관되게 유지됨을 보여줍니다.</p>                </div>            </div>                        <!-- 본문 섹션 3 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">📊</span>                    인터넷 트래픽, '코끼리와 쥐'의 법칙                </h2>                <div class="section-content">                    <p>오랜 질문 중 하나인 '코끼리와 쥐' 현상, 즉 대부분의 플로우는 작고 일부는 거대하다는 것을 정량적으로 확인할 시간입니다. 우리는 누적 분포 함수(CDF) 그래프와 로그 스케일 축을 사용해 이 특성을 시각화했습니다.</p>                    <p><strong>패킷 수: 대부분은 '쥐', 소수는 '코끼리'</strong></p>                    <p>클라우드플레어 서버가 클라이언트에게 보낸 응답 패킷 수를 보면, 중앙값은 <strong>12개</strong>에 불과합니다. 이는 전체 인터넷 연결의 절반이 매우 적은 패킷으로 구성된다는 의미죠. 90th 백분위수도 107개로, 대부분의 연결이 가볍습니다. 하지만 평균은 240개로, 소수의 대규모 연결(비디오 스트리밍, 대용량 파일 전송)이 분포를 크게 왜곡하는 '코끼리 플로우'를 보여줍니다.</p>                    <div class="metric-grid">                        <div class="metric-card">                            <div class="metric-label">MEDIAN PACKETS</div>                            <div class="metric-value">12개</div>                            <div class="metric-desc">전체 연결 응답 패킷 중앙값</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">90TH PCT PACKETS</div>                            <div class="metric-value">107개</div>                            <div class="metric-desc">전체 연결 응답 패킷 상위 10%</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">HTTP/1.X MEDIAN</div>                            <div class="metric-value">10개</div>                            <div class="metric-desc">HTTP/1.X 응답 패킷 중앙값</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">HTTP/2 MEDIAN</div>                            <div class="metric-value">16개</div>                            <div class="metric-desc">HTTP/2 응답 패킷 중앙값</div>                        </div>                    </div>                    <p>HTTP/1.X는 중앙값 10개, 90th 백분위수 63개로 매우 작은 반면, HTTP/2는 중앙값 16개, 90th 백분위수 170개로 더 많은 패킷을 교환합니다. 이는 HTTP/2가 하나의 연결로 여러 스트림을 멀티플렉싱하고 제어 프레임을 사용하는 방식 때문입니다.</p>                    <p><strong>패킷 송수신 균형: 클라이언트가 더 많이 보낸다?</strong></p>                    <p>클라우드플레어 서버가 보낸 패킷과 클라이언트가 받은 패킷의 비율을 보면, 중앙값은 <strong>0.91</strong>입니다. 즉, 절반의 연결에서 클라이언트가 서버보다 약간 더 많은 패킷을 보낸다는 의미죠. 이는 주로 TLS 핸드셰이크(ClientHello), HTTP 제어 요청 헤더, 데이터 ACK 때문입니다. 하지만 평균은 1.28로, 대용량 다운로드 같은 서버-클라이언트 방향의 트래픽이 긴 꼬리를 만듭니다.</p>                    <p><strong>바이트 송신량: 서버가 압도적으로 많이 보낸다</strong></p>                    <p>패킷과 비슷하게 바이트 송신량 역시 긴 꼬리를 보입니다. HTTP/1.X는 중앙값 4.8 KB, 90th 백분위수 51 KB, HTTP/2는 중앙값 6 KB, 90th 백분위수 146 KB를 전송합니다. 평균은 각각 224 KB, 390 KB로 역시 대용량 전송이 skew를 만듭니다.</p>                    <div class="metric-grid">                        <div class="metric-card">                            <div class="metric-label">MEDIAN BYTES SENT</div>                            <div class="metric-value">4.8 KB</div>                            <div class="metric-desc">HTTP/1.X 송신 바이트 중앙값</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">90TH PCT BYTES SENT</div>                            <div class="metric-value">51 KB</div>                            <div class="metric-desc">HTTP/1.X 송신 바이트 상위 10%</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">MEDIAN BYTES SENT</div>                            <div class="metric-value">6 KB</div>                            <div class="metric-desc">HTTP/2 송신 바이트 중앙값</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">90TH PCT BYTES SENT</div>                            <div class="metric-value">146 KB</div>                            <div class="metric-desc">HTTP/2 송신 바이트 상위 10%</div>                        </div>                    </div>                    <p>서버가 보낸 바이트와 클라이언트가 받은 바이트 비율의 중앙값은 <strong>3.78</strong>입니다. 이는 절반의 연결에서 서버가 클라이언트보다 거의 4배 많은 데이터를 보낸다는 의미죠. 평균은 81.06으로 훨씬 높아, 다운로드 중심의 트래픽이 강한 비대칭성을 보여줍니다.</p>                </div>            </div>                        <!-- 본문 섹션 4 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">⏱️</span>                    연결은 얼마나 오래, 무엇을 실어 나르는가?                </h2>                <div class="section-content">                    <p>데이터 교환량만큼이나 중요한 것이 바로 연결이 지속되는 시간입니다. 이는 트래픽 패턴과 사용자 경험에 깊은 영향을 미치거든요.</p>                    <p><strong>연결 지속 시간: 대부분 5초 미만의 짧은 만남</strong></p>                    <p>전체 연결의 중앙값 지속 시간은 <strong>4.7초</strong>입니다. 절반의 연결이 5초 이내에 완료된다는 뜻이죠. 10th 백분위수는 0.1초, 90th 백분위수는 300초로, 대부분의 웹 트래픽이 짧고 일시적임을 알 수 있습니다. 물론 킵얼라이브(keep-alives)를 통해 며칠 동안 지속되는 매우 긴 연결도 존재하지만, 이들이 평균(96초)을 높게 만들 뿐 대다수는 '짧은 만남'입니다.</p>                    <div class="metric-grid">                        <div class="metric-card">                            <div class="metric-label">MEDIAN DURATION</div>                            <div class="metric-value">4.7초</div>                            <div class="metric-desc">전체 연결 지속 시간 중앙값</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">90TH PCT DURATION</div>                            <div class="metric-value">300초</div>                            <div class="metric-desc">전체 연결 지속 시간 상위 10%</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">MEAN DURATION</div>                            <div class="metric-value">96초</div>                            <div class="metric-desc">소수의 긴 연결로 인해 평균이 높음</div>                        </div>                    </div>                    <p><strong>연결당 요청 수: HTTP/2의 멀티플렉싱 효과</strong></p>                    <p>하나의 TCP 연결이 얼마나 많은 HTTP 요청을 처리하는지를 보면, HTTP/1.X와 HTTP/2 모두 중앙값은 <strong>1개</strong>입니다. 이는 연결 재사용이 제한적임을 시사하죠. 하지만 HTTP/2는 멀티플렉싱 덕분에 90th 백분위수에서 10개의 요청을 처리하며, 연결 결합(connection coalescing)을 통해 수천 개의 요청을 처리하는 극단적인 경우도 있습니다. 반면 HTTP/1.X는 90th 백분위수도 2개 미만으로 현저히 낮습니다.</p>                    <div class="metric-grid">                        <div class="metric-card">                            <div class="metric-label">MEDIAN REQUESTS</div>                            <div class="metric-value">1개</div>                            <div class="metric-desc">HTTP/1.X 및 HTTP/2 연결당 요청 중앙값</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">HTTP/2 90TH REQ</div>                            <div class="metric-value">10개</div>                            <div class="metric-desc">HTTP/2 연결당 요청 상위 10%</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">USER-DRIVEN 90TH</div>                            <div class="metric-value">5개</div>                            <div class="metric-desc">비-데이터센터(사용자) 트래픽 연결당 요청 수</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">DC-DRIVEN 90TH</div>                            <div class="metric-value">2개</div>                            <div class="metric-desc">데이터센터(자동화) 트래픽 연결당 요청 수</div>                        </div>                    </div>                    <p>클라이언트 유형에 따라 살펴보면, 데이터센터(DC)에서 발생하는 자동화된 트래픽은 연결당 평균 3개, 90th 백분위수 2개로 요청 수가 적습니다. 반면 사용자 주도(비-DC) 트래픽은 평균 5개, 90th 백분위수 5개로 약간 더 높습니다. 이는 브라우저나 앱이 하나의 연결로 여러 리소스를 가져오는 경향을 반영하지만, 여전히 대부분의 연결이 짧고 요청 수도 적음을 보여줍니다.</p>                </div>            </div>                        <!-- 본문 섹션 5 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">🚀</span>                    숨겨진 경로 특성: MTU와 ICWND                </h2>                <div class="section-content">                    <p>연결 수준 데이터는 네트워크 경로 자체의 특성까지 유추할 수 있게 합니다. 여기서 Path MTU와 초기 혼잡 윈도우(ICWND)를 살펴볼게요.</p>                    <p><strong>Path MTU: 대부분 1500바이트, 하지만 예외도 존재</strong></p>                    <p>경로 MTU(PMTU)는 단편화 없이 전송될 수 있는 최대 패킷 크기인데, 저희 데이터에서 중앙값은 <strong>1500바이트</strong>로 일반적인 이더넷 MTU와 일치합니다. 90th 백분위수도 1500바이트였어요. 하지만 10th 백분위수는 1420바이트로, VPN이나 IPv6tov4 터널처럼 MTU가 약간 작은 경로도 있음을 알 수 있습니다. IPv4 연결에서는 리눅스 커널의 최소 허용 PMTU 값인 552바이트까지 관찰되었고요.</p>                    <div class="highlight-box">                        <p><strong>초기 혼잡 윈도우(ICWND): BBR은 왜 이렇게 높게 설정할까?</strong></p>                        <p>ICWND는 데이터 전송 초기, ACK를 기다리지 않고 전송할 수 있는 패킷 수를 결정하는 중요한 파라미터입니다. 특히 짧은 연결이 지배적인 인터넷 트래픽에서 ICWND는 성능에 지대한 영향을 미칩니다. 너무 낮으면 병목 대역폭에 도달하는 데 더 많은 RTT(왕복 시간)가 필요하고, 너무 높으면 네트워크를 압도하여 불필요한 패킷 손실을 야기할 수 있죠.</p>                    </div>                    <p>BBR 혼잡 제어 알고리즘이 '슬로우 스타트(slow start)'를 종료하는 시점의 혼잡 윈도우 크기(ICWND)를 보면, 중앙값은 약 <strong>464 KB</strong>입니다. 이는 일반적인 1,500바이트 MTU 기준으로 약 310개 패킷에 해당하죠. 이 값은 예상보다 매우 높았는데, 이는 BBR이 경로의 가용 용량 추정치인 BDP(대역폭-지연 곱)보다 혼잡 윈도우를 더 높게 설정하도록 설계되었기 때문입니다.</p>                    <div class="metric-grid">                        <div class="metric-card">                            <div class="metric-label">MEDIAN BBR CWND</div>                            <div class="metric-value">464KB</div>                            <div class="metric-desc">BBR의 초기 혼잡 윈도우 중앙값 (~310패킷)</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">MEDIAN BBR BDP</div>                            <div class="metric-value">77KB</div>                            <div class="metric-desc">BBR의 BDP 추정치 중앙값 (~50패킷)</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">ICWND IMPACT</div>                            <div class="metric-value">30-40%↑</div>                            <div class="metric-desc">작은 연결 성능 향상 잠재력</div>                        </div>                    </div>                    <p>실제로 BBR의 BDP 추정치(중앙값 약 77 KB, 약 50 패킷)와 비교해보니, BDP 추정치가 훨씬 더 안정적이고 현실적인 값을 보였습니다. 이 인사이트는 10년 넘게 기본값으로 유지된 10개 패킷이라는 ICWND 값을 재고할 중요한 계기가 됩니다. 클라우드플레어 내부 실험 결과, ICWND 크기 조정만으로 작은 연결의 성능이 <strong>30-40%</strong>까지 향상될 수 있음을 확인했거든요.</p>                </div>            </div>                        <!-- 본문 섹션 6 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">💡</span>                    더 깊은 이해, 더 나은 인터넷                </h2>                <div class="section-content">                    <p>클라우드플레어의 분석 결과는 인터넷 연결이 '코끼리와 쥐' 현상 및 송수신 바이트/패킷 비율에서 볼 수 있듯이, 매우 이질적이고 비대칭적인 특성을 가지고 있음을 다시 한번 명확히 보여줍니다. 특히 다운로드 중심의 트래픽에서 서버가 클라이언트보다 훨씬 더 많은 데이터를 전송하고, 대부분의 연결은 짧고 간결하다는 점은 중요한 시사점을 던져줍니다.</p>                    <p>이러한 연결 특성에 대한 깊은 이해는 네트워크 성능, 안정성, 사용자 경험을 개선하는 데 지속적으로 기여할 것입니다. 클라우드플레어는 앞으로도 이 연구를 바탕으로 '클라우드플레어 레이더(Cloudflare Radar)'에 연결 수준 통계를 게시하여 더 많은 사람들이 이 인사이트를 활용할 수 있도록 할 계획입니다.</p>                    <p>저희의 네트워크 개선 노력은 계속될 것이며, 연구자, 학계, 인턴을 비롯해 이 분야에 관심 있는 모든 분들의 참여를 환영합니다. 함께 지식을 공유하고 협력함으로써, 우리는 모두에게 더 빠르고 안전하며 신뢰할 수 있는 인터넷을 만들어갈 수 있을 겁니다.</p>                </div>            </div>                        <!-- CTA -->            <div class="cta-box">                <h3>실전 적용 인사이트: 클라우드플레어의 네트워크 최적화</h3>                <p>클라우드플레어의 TCP 연결 특성 연구는 단순한 데이터 공개를 넘어 <strong>네트워크 설계의 패러다임 전환</strong>을 시사합니다. '코끼리'와 '쥐'가 공존하는 비대칭 트래픽 패턴과 최적의 ICWND를 파악하여 낡은 기본값을 재평가할 기회를 제공하죠. 이 인사이트를 통해 더 빠르고 안정적인 인터넷 경험을 만들 수 있습니다.</p>                <a href="https://blog.cloudflare.com/measuring-network-connections-at-scale/" class="cta-button" target="_blank">원문 읽기 →</a>            </div>        </div>                <!-- 푸터 -->        <div class="footer">            <p><strong>핵심 요약</strong>: 클라우드플레어가 수집한 대규모 TCP 연결 데이터 분석 결과, 인터넷 트래픽은 '코끼리와 쥐' 현상 및 비대칭적 특성을 보이며, 특히 ICWND 최적화가 작은 연결의 성능을 30-40% 개선할 수 있음을 밝혔습니다.</p>            <p>출처: <a href="https://blog.cloudflare.com/measuring-network-connections-at-scale/" target="_blank">Cloudflare Engineering 블로그 - Measuring characteristics of TCP connections at Internet scale</a></p>        </div>    </div></body></html>```