<!DOCTYPE html><html lang="ko"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>GitHub Security Lab이 LLM으로 보안 취약점 오탐 줄이고 실제 위협 찾은 방법</title>    <link rel="preconnect" href="https://fonts.googleapis.com">    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>    <link href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600;9..144,700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">    <style>        @import url("https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable-dynamic-subset.min.css");                * {            margin: 0;            padding: 0;            box-sizing: border-box;        }                body {            font-family: "Pretendard Variable", -apple-system, BlinkMacSystemFont, system-ui, sans-serif;            background: #faf8f5;            color: #2d2d2d;            line-height: 1.7;            padding: 20px;            font-size: 16px;        }                .container {            max-width: 850px;            margin: 0 auto;            background: #ffffff;            border-radius: 16px;            overflow: hidden;            box-shadow: 0 4px 20px rgba(46, 164, 79, 0.08); /* Updated shadow color for GitHub accent */            animation: fade-in 0.6s ease;        }                @keyframes fade-in {            from {                opacity: 0;                transform: translateY(20px);            }            to {                opacity: 1;                transform: translateY(0);            }        }                .header {            background: linear-gradient(135deg,  #24292E 0%,  #181B1F 100%); /* GitHub gradient */            padding: 48px 40px;            color: #ffffff;        }                .header-label {            font-family: 'JetBrains Mono', monospace;            font-size: 13px;            letter-spacing: 1.5px;            opacity: 0.9;            margin-bottom: 12px;            text-transform: uppercase;        }                .header h1 {            font-family: 'Fraunces', serif;            font-size: 36px;            font-weight: 700;            line-height: 1.3;            margin-bottom: 16px;        }                .header-meta {            font-size: 14px;            opacity: 0.85;            font-weight: 500;        }                .content {            padding: 48px 40px;        }                .intro {            font-size: 18px;            line-height: 1.8;            color: #3d3d3d;            margin-bottom: 40px;            padding-bottom: 32px;            border-bottom: 2px solid #f0ebe5;            animation: fade-slide-up 0.6s ease 0.2s both;        }                .intro p {            margin-bottom: 16px;        }                .intro p:last-child {            margin-bottom: 0;        }                .intro strong {            color: #2EA44F; /* GitHub accent color */            font-weight: 600;        }                .intro ul {            list-style: none;            padding-left: 0;            margin: 20px 0;        }                .intro ul li {            padding-left: 28px;            margin-bottom: 10px;            position: relative;            line-height: 1.7;        }                .intro ul li::before {            content: "•";            position: absolute;            left: 0;            color: #2EA44F; /* GitHub accent color */            font-weight: 600;            font-size: 20px;        }                @keyframes fade-slide-up {            from {                opacity: 0;                transform: translateY(20px);            }            to {                opacity: 1;                transform: translateY(0);            }        }                .section {            margin-bottom: 40px;            animation: fade-slide-up 0.6s ease both;        }                .section:nth-child(2) { animation-delay: 0.3s; }        .section:nth-child(3) { animation-delay: 0.4s; }        .section:nth-child(4) { animation-delay: 0.5s; }        .section:nth-child(5) { animation-delay: 0.6s; }        .section:nth-child(6) { animation-delay: 0.7s; }                .section-title {            font-family: 'Fraunces', serif;            font-size: 24px;            font-weight: 700;            color: #2EA44F; /* GitHub accent color */            margin-bottom: 20px;            display: flex;            align-items: center;            gap: 12px;        }                .section-emoji {            font-size: 28px;        }                .section-content {            font-size: 16px;            line-height: 1.8;            color: #3d3d3d;        }                .section-content p {            margin-bottom: 16px;        }                .section-content p:last-child {            margin-bottom: 0;        }                .highlight-box {            background: #f0fff8; /* Light green for GitHub */            border-left: 4px solid #2EA44F; /* GitHub accent color */            padding: 20px 24px;            margin: 20px 0;            border-radius: 0 8px 8px 0;        }                .highlight-box p {            margin-bottom: 12px;            font-size: 15px;        }                .highlight-box p:last-child {            margin-bottom: 0;        }                .highlight-box strong {            color: #2EA44F; /* GitHub accent color */        }                .code-box {            background: #2d2d2d;            color: #f0ebe5;            padding: 20px 24px;            border-radius: 8px;            font-family: 'JetBrains Mono', monospace;            font-size: 13px;            line-height: 1.6;            margin: 20px 0;            overflow-x: auto;        }                .code-box code {            color: #6dd4c4;        }                .phase-box {            background: #ffffff;            border: 2px solid #2EA44F; /* GitHub accent color */            padding: 24px;            margin: 20px 0;            border-radius: 12px;        }                .phase-title {            font-family: 'Fraunces', serif;            font-size: 20px;            font-weight: 700;            color: #2EA44F; /* GitHub accent color */            margin-bottom: 16px;            display: flex;            align-items: center;            gap: 10px;        }                .phase-content {            font-size: 15px;            line-height: 1.7;            color: #3d3d3d;        }                .phase-content p {            margin-bottom: 12px;        }                .phase-content p:last-child {            margin-bottom: 0;        }                .metric-grid {            display: grid;            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));            gap: 16px;            margin: 24px 0;        }                .metric-card {            background: #faf8f5;            padding: 20px;            border-radius: 12px;            border: 1px solid #f0ebe5;            transition: all 0.3s ease;        }                .metric-card:hover {            transform: translateY(-4px);            box-shadow: 0 6px 20px rgba(46, 164, 79, 0.12); /* GitHub accent color */        }                .metric-label {            font-family: 'JetBrains Mono', monospace;            font-size: 12px;            color: #8d6e5f;            margin-bottom: 8px;            text-transform: uppercase;            letter-spacing: 0.5px;        }                .metric-value {            font-family: 'Fraunces', serif;            font-size: 28px;            font-weight: 700;            color: #2EA44F; /* GitHub accent color */            margin-bottom: 8px;        }                .metric-desc {            font-size: 14px;            color: #5d5d5d;            line-height: 1.5;        }                .bullet-list {            list-style: none;            padding-left: 0;            margin: 16px 0;        }                .bullet-list li {            padding-left: 32px;            margin-bottom: 12px;            position: relative;            line-height: 1.7;        }                .bullet-list li::before {            content: "→";            position: absolute;            left: 0;            color: #2EA44F; /* GitHub accent color */            font-weight: 600;            font-size: 18px;        }                .stage-grid {            display: grid;            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));            gap: 12px;            margin: 24px 0;        }                .stage-card {            background: #f0fff8; /* Light green for GitHub */            border: 1px solid #2EA44F; /* GitHub accent color */            padding: 16px;            border-radius: 8px;            text-align: center;        }                .stage-number {            font-family: 'Fraunces', serif;            font-size: 32px;            font-weight: 700;            color: #2EA44F; /* GitHub accent color */            margin-bottom: 8px;        }                .stage-name {            font-weight: 700;            color: #2d2d2d;            margin-bottom: 8px;            font-size: 14px;        }                .stage-desc {            font-size: 12px;            color: #5d5d5d;            line-height: 1.5;        }        .image-box {            margin: 32px 0;            background: #fafafa;            border-radius: 12px;            padding: 16px;            text-align: center;        }        .image-box img {            max-width: 100%;            height: auto;            border-radius: 8px;            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);            margin-bottom: 12px;        }        .image-caption {            font-size: 13px;            color: #666;            font-style: italic;            margin: 0;            padding-top: 8px;        }        .image-grid {            display: grid;            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));            gap: 20px;            margin: 32px 0;        }        .cta-box {            background: linear-gradient(135deg,  #24292E 0%,  #181B1F 100%); /* GitHub gradient */            color: #ffffff;            padding: 32px;            border-radius: 12px;            margin-top: 40px;            text-align: center;        }                .cta-box h3 {            font-family: 'Fraunces', serif;            font-size: 22px;            margin-bottom: 16px;        }                .cta-box p {            font-size: 15px;            line-height: 1.7;            opacity: 0.95;            margin-bottom: 20px;        }                .cta-button {            display: inline-block;            background: #ffffff;            color: #2EA44F; /* GitHub accent color */            padding: 14px 32px;            border-radius: 8px;            text-decoration: none;            font-weight: 600;            font-size: 15px;            transition: all 0.3s ease;        }                .cta-button:hover {            transform: translateY(-2px);            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);        }                .footer {            background: #faf8f5;            padding: 32px 40px;            text-align: center;            font-size: 14px;            color: #8d6e5f;            border-top: 1px solid #f0ebe5;        }                .footer p {            margin-bottom: 8px;        }                .footer a {            color: #2EA44F; /* GitHub accent color */            text-decoration: none;            font-weight: 600;        }                .footer a:hover {            text-decoration: underline;        }                @media (max-width: 768px) {            body {                padding: 12px;            }                        .header {                padding: 32px 24px;            }                        .header h1 {                font-size: 28px;            }                        .content {                padding: 32px 24px;            }                        .intro {                font-size: 16px;            }                        .section-title {                font-size: 20px;            }                        .metric-grid, .stage-grid {                grid-template-columns: 1fr;            }            .image-grid {                grid-template-columns: 1fr;            }            .footer {                padding: 24px;            }        }    </style></head><body>    <div class="container">        <!-- 헤더 -->        <div class="header">            <div class="header-label">GITHUB SECURITY LAB</div>            <h1>GitHub Security Lab이 LLM으로 보안 취약점 오탐 줄이고 실제 위협 찾은 방법</h1>            <div class="header-meta">30개 이상의 실제 취약점 발견 & 수동 오탐 분석 시간 획기적 단축</div>        </div>                <div class="content">            <!-- 도입부 -->            <div class="intro">                <p>보안 알림을 분류(triage)하는 일은 늘 지루하고 반복적입니다. 특히 수많은 오탐(false positive) 속에서 실제 위협을 찾아내는 건 숙련된 보안 전문가에게도 만만치 않은 일이죠. 패턴이 미묘하게 다르면 기존 도구로는 걸러내기 어렵고, 결국 사람이 일일이 코드를 들여다봐야 합니다. 이런 비효율적인 작업 때문에 핵심 보안 업무에 집중하기 어려웠던 경험, 다들 한두 번쯤 있으실 거예요.</p>                                <p>그런데 대규모 언어 모델(LLM)은 이런 '모호한' 패턴 인식에 탁월한 능력을 보입니다. 기존 도구가 잡아내지 못했던 미묘한 논리적 흐름이나 코드의 의미론적 맥락을 훨씬 잘 이해하죠. GitHub Security Lab은 이 LLM의 잠재력에 주목했습니다. 반복적이고 지루한 보안 알림 분류 작업을 LLM으로 자동화하여 전문가의 부담을 덜고, 더 나아가 숨겨진 실제 취약점까지 찾아낼 수 있지 않을까요?</p>                                <p>이 글에서는 GitHub Security Lab이 어떻게 LLM과 자체 개발한 <code>Taskflow Agent</code> 프레임워크를 활용해 보안 알림 분류 작업을 혁신했는지 그 비결을 자세히 들여다볼 거예요. 특히 다음 내용을 중심으로 살펴볼 겁니다.</p>                                <ul>                    <li><strong>보안 알림 분류의 고질적인 페인 포인트</strong> - 오탐과 반복 작업이 주는 비효율성</li>                    <li><strong>LLM 기반 <code>Taskflow Agent</code>의 작동 원리</strong> - 작은 태스크와 MCP 서버의 시너지</li>                    <li><strong>CodeQL 알림을 실제 취약점 보고서로 전환하는 여정</strong> - 정보 수집부터 검증까지</li>                    <li><strong>GitHub Actions 및 JavaScript/TypeScript 취약점 분류 사례</strong> - Claude Sonnet 3.5 활용</li>                    <li><strong>Taskflow 개발을 위한 GitHub Security Lab의 실전 팁</strong> - 재사용성과 일관성 확보 전략</li>                </ul>            </div>                        <!-- 본문 섹션 1 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">🧩</span>                    LLM, 보안 알림 분류의 고질적인 페인 포인트를 해결하다                </h2>                <div class="section-content">                    <p>보안 알림 분류는 종종 인간 감정사에게는 명백하지만 공식적인 코드 패턴으로 인코딩하기는 어려운 패턴으로 인해 오탐이 발생하는 경우가 많습니다. 이러한 오탐은 매우 반복적인 작업이므로 많은 시간을 낭비하게 됩니다. 하지만 대규모 언어 모델(LLM)은 전통적인 도구가 어려워하는 '모호한' 패턴 매칭에 탁월하죠. GitHub Security Lab은 이러한 LLM의 강점을 활용하기 위해 <code>GitHub Security Lab Taskflow Agent</code> AI 프레임워크를 사용하기 시작했고, 매우 효과적이라는 것을 확인했습니다.</p>                    <p>이 자동화 프로세스는 다음과 같은 경우에 특히 좋은 후보가 될 수 있습니다:</p>                    <ul class="bullet-list">                        <li>명확하고 잘 정의된 목표를 가진 여러 반복적인 단계로 이루어진 작업일 때.</li>                        <li>기존 프로그래밍으로는 식별하기 어렵지만, 인간 감정사에게는 비교적 쉬운 코드 내 논리 또는 의미론을 찾아야 하는 단계가 포함될 때. 이런 경우 보통 많은 '고무밴드' 휴리스틱이나 제대로 작성되지 않은 정규 표현식을 사용하게 되거든요. 바로 이런 부분이 LLM 자동화의 핵심 기회가 됩니다!</li>                    </ul>                    <p>이러한 기준을 충족한다면, LLM과 <code>Taskflow Agent</code>를 사용하여 자동화하고, MCP 서버를 통해 기존 프로그래밍에 적합한 작업을 수행하여 효율성을 극대화할 수 있습니다.</p>                </div>            </div>                        <!-- 본문 섹션 2 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">⚙️</span>                    <code>Taskflow Agent</code>: LLM과 구조화된 태스크의 시너지                </h2>                <div class="section-content">                    <p><code>Taskflow</code>는 LLM으로 수행하고자 하는 일련의 작업을 YAML 파일로 정의한 것입니다. 이를 통해 다양한 작업을 완료하기 위한 프롬프트를 작성하고, 서로 의존하는 태스크를 구성할 수 있습니다. <code>seclab-taskflow-agent</code> 프레임워크는 이러한 태스크를 순서대로 실행하고 결과를 다음 태스크로 전달하는 역할을 합니다.</p>                    <div class="image-box">                        <img src="https://github.blog/wp-content/uploads/2026/01/01_sample-taskflow.png?resize=1024%2C209" alt="Simplified depiction of taskflow with three tasks in order: fetch code scanning results, audit each result, create issues containing verdict.">                        <p class="image-caption">그림 1. 코드 스캐닝 알림 분류를 위한 간소화된 Taskflow</p>                    </div>                    <p>하나의 거대한 프롬프트 대신 <code>Taskflow</code>를 사용하는 이유는 LLM의 컨텍스트 윈도우가 제한적이며, 복잡한 다단계 작업을 한 번에 제대로 완료하지 못하는 경우가 많기 때문입니다. 일부 단계가 종종 누락되는데, <code>Taskflow</code>를 통해 작업을 구성하면 이러한 문제를 피할 수 있죠. 컨텍스트 윈도우가 더 큰 LLM에서도 <code>Taskflow</code>는 작업을 제어하고 디버깅하며, 더 크고 복잡한 작업을 수행하는 데 유용하다는 것을 확인했습니다.</p>                    <p><code>seclab-taskflow-agent</code>는 배치 "for 루프" 스타일의 작업을 비동기적으로 수행할 수도 있습니다. 알림을 감사할 때, 우리는 종종 동일한 프롬프트와 작업을 모든 알림에 적용하고 싶지만, 알림별 세부 정보는 달라야 합니다. <code>seclab-taskflow-agent</code>는 템플릿화된 프롬프트를 사용하여 알림을 반복하고, 각 알림 실행 시 특정 세부 정보를 대체할 수 있도록 합니다.</p>                    <p>특히 정보 수집 단계에서는 LLM이 환각(hallucination)을 줄이고 정보의 정확성을 높이도록 정확한 소스 코드 참조(파일 및 라인 번호 포함)를 지시합니다. 수집된 정보는 '감사 노트(audit notes)'에 저장되며, 다음 태스크는 이전 태스크의 노트에 자신의 노트를 추가할 수 있습니다. 각 정보 수집 태스크는 서로 독립적이어서, 특정 태스크가 자신의 범위에 집중할 수 있도록 돕습니다. 최종적으로 알림과 관련된 '정보 묶음'이 노트 형태로 감사 태스크에 전달됩니다.</p>                    <div class="image-box">                        <img src="https://github.blog/wp-content/uploads/2026/01/02_note-taking3.excalidraw.png?resize=1024%2C347" alt="Two tasks in order displaying which notes are added to the general notes in each step. With the step trigger analysis the notes added are triggers, permissions and secrets among others. The second task “audit injection point” potentially adds notes such as sanitizers and to the notes.">                        <p class="image-caption">그림 2. Taskflow 내 정보 수집 및 노트 추가 흐름</p>                    </div>                </div>            </div>                        <!-- 본문 섹션 3 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">🛠️</span>                    CodeQL 알림이 실제 취약점 보고서가 되기까지: 4단계 여정                </h2>                <div class="section-content">                    <p>GitHub Security Lab은 주기적으로 특정 오픈소스 레포지토리들을 대상으로 CodeQL 쿼리를 실행합니다. 이러한 알림을 분류하는 과정은 매우 반복적이며, 일부 알림의 오탐 원인은 유사하고 쉽게 파악될 수 있습니다. 예를 들어, GitHub Actions 알림 분류 시 오탐은 종종 레포지토리 관리자만 취약한 워크플로우를 트리거할 수 있도록 하는 검사나, 취약한 워크플로우가 구성에서 비활성화된 경우 발생합니다. 이러한 접근 제어 검사는 쉽게 식별할 수 있는 코드 패턴이 없어 CodeQL과 같은 정적 분석기가 탐지하기 어렵지만, 코드 의미론에 대한 일반 지식을 가진 인간 감정사는 쉽게 식별할 수 있습니다. 따라서 LLM이 이러한 접근 제어 검사를 식별하고 오탐을 제거할 수 있을 것이라고 예상했습니다.</p>                    <p>Taskflow는 일반적으로 몇 가지 다른 단계로 나뉘는 태스크로 구성됩니다. 이 단계를 통해 CodeQL 알림이 실제 취약점 보고서로 전환되는 과정을 살펴봅니다.</p>                    <div class="highlight-box">                        <p><strong>1. 정보 수집 단계</strong></p>                        <p>이 단계에서 LLM은 알림과 관련된 다양한 정보를 수집하도록 지시받습니다. 예를 들어, GitHub Actions 알림의 경우 GitHub 워크플로우 파일에 설정된 권한, 워크플로우를 트리거하는 이벤트, 워크플로우 비활성화 여부 등을 확인합니다. 이는 일반적으로 간단하고 잘 정의된 지침을 따르는 독립적인 태스크를 포함하여, 수집된 정보의 일관성을 보장합니다. 수집된 정보가 정확하고 환각을 줄이기 위해 LLM에게 파일 및 라인 번호를 포함한 소스 코드의 정확한 참조를 포함하도록 지시합니다.</p>                    </div>                    <div class="highlight-box">                        <p><strong>2. 감사(Audit) 단계</strong></p>                        <p>이 단계에서 LLM은 수집된 정보를 검토하고, 오탐으로 판명된 알림 결과를 걸러내기 위한 특정 검사 목록을 수행합니다. 예를 들어, GitHub Actions 알림을 분류할 때 취약한 워크플로우를 트리거하는 이벤트에 대한 정보를 수집했다면, 감사 단계에서는 이러한 이벤트가 공격자에 의해 트리거될 수 있는지 또는 특권 컨텍스트에서 실행되는지 여부를 확인합니다. 이 단계를 거치면 인간 감정사에게는 명백한 많은 오탐이 제거됩니다.</p>                    </div>                    <div class="highlight-box">                        <p><strong>3. 의사 결정 및 보고서 생성 단계</strong></p>                        <p>감사 단계를 통과한 알림에 대해서는 수집된 정보와 감사 단계의 의사 결정 근거를 사용하여 버그 보고서를 생성합니다. 프롬프트에서 보고서 형식과 필요한 정보에 대해 매우 정확하게 지시하며, 특히 간결하지만 결과를 쉽게 확인할 수 있는 정보(정확한 코드 참조 및 코드 블록 포함)를 요구합니다. 이 단계에서는 추가 분석 없이 이전 단계의 노트에서 수집된 정보를 사용하여 보고서를 작성하며, 이는 환각 발생 가능성을 크게 줄입니다.</p>                    </div>                    <div class="highlight-box">                        <p><strong>4. 보고서 유효성 검사 및 이슈 생성 단계</strong></p>                        <p>보고서가 작성된 후, LLM은 보고서에 모든 관련 정보가 포함되어 있는지, 그리고 정보의 일관성이 유지되는지 확인하도록 지시받습니다. 누락되거나 일관성 없는 정보는 종종 환각 또는 기타 오탐의 원인(예: 공격자 제어 입력 추적 실패)을 나타내므로, 이러한 경우 보고서를 기각합니다. 보고서가 모든 정보를 포함하고 일관성이 있다면, GitHub Issue를 생성하여 알림을 추적합니다. GitHub Issue 생성은 결과를 검토하기 쉽게 할 뿐만 아니라 분석을 확장하는 방법도 제공합니다.</p>                    </div>                    <p>생성된 GitHub Issue를 검토하고 확인한 후, 우리는 종종 감사 과정에서 놓쳤던 오탐의 원인을 발견합니다. 또한, LLM이 알림이 유효하다고 판단했지만, 인간 검토자가 동의하지 않고 에이전트에게 알려지지 않은 이유로 오탐을 발견하는 경우, 인간 검토자는 이를 <a href="https://docs.github.com/en/code-security/code-scanning/managing-code-scanning-alerts/resolving-code-scanning-alerts#dismissing-alerts">알림 해제 이유</a> 또는 이슈 댓글로 문서화할 수 있습니다. 에이전트가 향후 유사한 사례를 분석할 때, 이러한 이슈와 알림 해제 이유에 저장된 과거 분석 정보를 모두 인지하여 새로운 인텔리전스를 지식 베이스에 통합하고 오탐 탐지에 더 효과적으로 활용됩니다.</p>                    <div class="image-box">                        <img src="https://github.blog/wp-content/uploads/2026/01/3-screenshot.png?resize=826%2C110" alt="Image showing LLM output that dismisses an alert.">                        <p class="image-caption">그림 3. LLM이 알림 해제 이유를 고려하여 알림을 해제하는 예시</p>                    </div>                </div>            </div>                        <!-- 본문 섹션 4 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">📊</span>                    GitHub Actions & JavaScript: LLM 분류, 실제 취약점을 찾아내다                </h2>                <div class="section-content">                    <p>우리는 CodeQL 규칙에 대해 주로 Claude Sonnet 3.5를 사용하여 <code>Taskflow</code>를 테스트했으며, 이 과정에서 다수의 실제 악용 가능한 취약점을 식별했습니다. <code>Taskflow</code>는 "종단 간" 분석을 수행하는 대신, 우리가 신속하게 결과를 확인할 수 있도록 모든 세부 정보와 결론을 담은 버그 보고서를 생성합니다. LLM에게 익스플로잇을 생성하여 결과를 검증하거나 테스트할 런타임 환경을 제공하지 않았음에도 불구하고, 결과는 매우 정확했으며 CodeQL 쿼리의 오탐을 신속하게 제거할 수 있었습니다.</p>                    <p><strong>GitHub Actions 알림 분류</strong></p>                    <p>분류한 특정 Actions 알림은 <a href="https://codeql.github.com/codeql-query-help/actions/actions-untrusted-checkout-critical/">신뢰할 수 없는 코드의 특권 컨텍스트 체크아웃</a>과 <a href="https://codeql.github.com/codeql-query-help/actions/actions-code-injection-critical/">코드 인젝션</a>입니다. 이러한 쿼리 분류는 많은 유사점을 공유합니다. 예를 들어, 둘 다 워크플로우 트리거 이벤트, 취약한 워크플로우의 권한, 워크플로우 호출자 추적 등을 포함하죠.</p>                    <p>수동으로 GitHub Actions 알림을 분류할 때 흔히 발생하는 오탐 원인은 다음과 같습니다.</p>                    <ul class="bullet-list">                        <li><strong>특권 컨텍스트 부재</strong>: 취약한 워크플로우가 특권 컨텍스트에서 실행되지 않을 때 발생합니다. 예를 들어, <code>pull_request_target</code>에 의해 트리거된 워크플로우는 특권 컨텍스트에서 실행되지만, <code>pull_request</code> 이벤트에 의해 트리거된 워크플로우는 그렇지 않습니다.</li>                        <li><strong>워크플로우 비활성화</strong>: 레포지토리에서 취약한 워크플로우가 명시적으로 비활성화된 경우입니다.</li>                        <li><strong>권한 제한</strong>: 취약한 워크플로우가 명시적으로 권한을 제한하고 비밀을 사용하지 않아 얻을 수 있는 특권이 거의 없을 때입니다.</li>                        <li><strong>취약점별 문제</strong>: 코드 인젝션의 경우 유효하지 않은 사용자 입력이나 새니타이저의 존재, 신뢰할 수 없는 체크아웃의 경우 유효한 코드 실행 지점의 부재 등입니다.</li>                        <li><strong>재사용 가능한 워크플로우의 호출자 문제</strong>: 취약한 워크플로우가 재사용 가능한 워크플로우이지만, 특권 컨텍스트에서 실행되는 다른 워크플로우에서 도달할 수 없을 때입니다.</li>                    </ul>                    <p>이러한 기준에 따라 분류 <code>Taskflow</code>는 정보 수집 및 감사 단계에서 다음 태스크들로 구성됩니다.</p>                    <ul class="bullet-list">                        <li><strong>워크플로우 트리거 분석</strong>: 취약한 워크플로우를 트리거하는 이벤트, 사용되는 권한 및 비밀을 수집합니다. 또한 워크플로우가 레포지토리에서 비활성화되었는지 확인합니다. 이 정보는 실행 중인 노트에 저장됩니다.</li>                        <li><strong>코드 인젝션 지점 분석</strong>: 코드 인젝션 지점의 위치와 주입되는 사용자 입력에 대한 정보를 수집합니다. 사용자 입력이 유효한 인젝션 위험인지, 그리고 새니타이저가 있는지 여부를 로컬 감사로 확인합니다.</li>                        <li><strong>워크플로우 사용자 분석</strong>: 취약한 워크플로우의 호출자를 찾고, 호출자의 트리거 이벤트, 권한, 비밀 사용 여부를 기록하는 간단한 호출자 분석을 수행합니다. 이 정보는 나중에 감사 태스크에서 취약한 워크플로우가 공격자에게 도달 가능한지 판단하는 데 사용됩니다.</li>                    </ul>                    <div class="image-box">                        <img src="https://github.blog/wp-content/uploads/2026/01/03_actions_code_injection.png?resize=1024%2C363" alt="Seven tasks of a taskflow connected in order with arrows: fetch alerts, trigger analysis, injection point analysis, workflow user analysis, review notes, create bug report and review bug report. All tasks but fetch alerts symbolize how they either iterate over alerts or alert notes.">                        <p class="image-caption">그림 4. <code>triage_actions_code_injection</code> Taskflow의 주요 구성 요소</p>                    </div>                    <p>정보 수집 및 감사 단계를 거친 후, 노트에는 취약한 워크플로우를 트리거하는 이벤트, 관련된 권한 및 비밀, 그리고 (재사용 가능한 워크플로우의 경우) 취약한 워크플로우를 사용하는 다른 워크플로우 및 이들의 트리거 이벤트, 권한, 비밀과 같은 정보가 포함됩니다. 이 정보는 버그 보고서의 기반이 됩니다. 정보가 완전하고 일관적인지 확인하기 위해 <code>review_report</code> 태스크가 사용되며, 그 후 <code>create_report</code> 태스크를 사용하여 GitHub Issue의 기반이 될 버그 보고서를 생성합니다. 다음은 LLM이 생성한 이슈의 예시입니다.</p>                    <div class="image-box">                        <img src="https://github.blog/wp-content/uploads/2026/01/4-screenshot.png?resize=887%2C996" alt="Image showing an issue created by the LLM.">                        <p class="image-caption">그림 5. LLM이 생성한 GitHub Issue 예시</p>                    </div>                    <p>우리는 GitHub Issues와 알림 해제 이유를 레포지토리별 보안 조치를 통합하고 추가 분석을 수행하는 수단으로 활용할 수 있습니다. <code>review_actions_injection_issues</code> Taskflow를 사용하여 레포지토리에서 알림 해제 이유를 먼저 수집합니다. 이 해제 이유는 GitHub Issue에 명시된 알림과 대조하여 확인됩니다. 이슈가 알림에 대한 모든 관련 정보와 코드 참조를 포함하므로, LLM은 이슈와 알림 해제 이유를 활용하여 분석을 심화하고 더 많은 오탐을 발견할 수 있습니다. 다음은 해제 이유를 기반으로 거부된 알림을 보여줍니다.</p>                    <div class="image-box">                        <img src="https://github.blog/wp-content/uploads/2026/01/5-screenshot.png?resize=887%2C443" alt="Image showing LLM output of reasons to reject an alert after taking into account of the dismissal reasons.">                        <p class="image-caption">그림 6. LLM이 해제 이유를 고려하여 알림을 거부하는 예시</p>                    </div>                    <div class="image-box">                        <img src="https://github.blog/wp-content/uploads/2026/01/04_swimlanes_create_review.png?resize=1024%2C619" alt="Five tasks separated in two swim lanes: the first swim lane named “create action issues” depicts tasks that are used for the issue creation taskflow starting with dismissing false positives and continuing with the tasks for issue creation for true and false positives. The second swim lane is titled “review action issues” and contains the tasks “collect alert dismissal reasons” and “review issues based on dismissal reasons.">                        <p class="image-caption">그림 7. GitHub Actions 이슈 생성 및 검토 Taskflow 구성 요소</p>                    </div>                    <p><strong>JavaScript 알림 분류</strong></p>                    <p>Actions 알림 분류와 유사하게, JavaScript/TypeScript 언어에 대한 코드 스캐닝 알림도 분류했습니다. JavaScript에서는 클라이언트 측 교차 사이트 스크립팅(XSS) CodeQL 규칙(<a href="https://codeql.github.com/codeql-query-help/javascript/js-xss/">js/xss</a>)에 대한 알림을 분류했습니다. 클라이언트 측 XSS 알림은 GitHub Actions 알림에 비해 소스, 싱크 및 데이터 흐름 면에서 더 다양한 양상을 보입니다. XSS 취약점 분석을 위한 프롬프트는 분류 담당자가 교육받은 결정을 내릴 수 있도록 돕는 데 초점을 맞추며, 알림을 악용 가능한 취약점으로 만드는 측면과 잠재적 이슈의 악용을 방지하는 요소를 강조합니다.</p>                    <p>수동으로 XSS 알림을 분류할 때 우리는 종종 다음과 같은 이유로 오탐을 식별했습니다.</p>                    <ul class="bullet-list">                        <li>정적 분석 도구가 확인할 수 없는 사용자 정의 또는 인식되지 않는 새니타이징 함수(예: 정규 표현식 사용).</li>                        <li>실제로 도달 불가능할 가능성이 있는 보고된 소스(예: 공격자가 웹 서버에서 직접 메시지를 보내야 하는 경우).</li>                        <li>잠재적으로 위험한 싱크로 흐르는 신뢰할 수 없는 데이터가 악용 불가능한 방식으로만 사용되는 경우.</li>                        <li>정적 분석 도구가 주어진 신뢰할 수 없는 데이터가 최종적으로 사용되는 전체 컨텍스트를 알지 못하는 경우.</li>                    </ul>                    <p>이러한 오탐을 바탕으로 관련 <code>Taskflow</code> 또는 활성 페르소나의 프롬프트가 확장되고 조정되었습니다. 프로젝트에서 특정 오탐이 발생하면, 프롬프트를 확장하여 오탐을 올바르게 표시하고(특정 소스/싱크에 대한 알림이 취약점으로 간주되지 않는 경우도 포함) 감사하는 것이 좋습니다.</p>                    <p>결과적으로, <code>triage_js_ts_client_side_xss</code> 및 <code>create_issues_js_ts</code> <code>Taskflow</code>를 실행한 후, 알림은 다음과 같은 GitHub Issue로 나타납니다.</p>                    <div class="image-box">                        <img src="https://github.blog/wp-content/uploads/2026/01/05_ai-triage-issue-tp-72.png?resize=1024%2C888" alt="A screenshot of a GitHub Issue titled 'Code scanning alert #72 triage report for js/xss,' showing two lists with reasons that make an alert and exploitable vulnerability or not.">                        <p class="image-caption">그림 8. LLM이 생성한 XSS 취약점(True Positive) 보고서 이슈 예시</p>                    </div>                    <p>이것은 추적할 가치가 있는 알림(결국 <code>javascript:</code> URL을 사용하여 악용 가능한 <a href="https://securitylab.github.com/advisories/GHSL-2025-110_openlibrary/">진짜 취약점</a>으로 밝혀짐)의 샘플이지만, <code>Taskflow Agent</code>가 오탐으로 판단한 알림에는 "FP"(False Positive) 레이블이 지정됩니다.</p>                    <div class="image-box">                        <img src="https://github.blog/wp-content/uploads/2026/01/06_ai-triage-issue-fp-1694.png?resize=1024%2C844" alt="A screenshot of a GitHub Issue titled 'Code scanning alert #1694 triage report for js/xss.' While it would show factors that make an alert exploitable it shows none, because the taskflow identified none. However, the issue shows a list of 7 items describing why the vulnerability is not exploitable.">                        <p class="image-caption">그림 9. LLM이 생성한 XSS 오탐(False Positive) 보고서 이슈 예시</p>                    </div>                </div>            </div>                        <!-- 본문 섹션 5 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">💡</span>                    Taskflow 개발자를 위한 GitHub Security Lab의 실전 팁                </h2>                <div class="section-content">                    <p>다음은 <code>Taskflow</code> 개발 시 유용하다고 생각하는 몇 가지 경험과 팁입니다. 이 팁들이 여러분만의 <code>Taskflow</code>를 만드는 데 도움이 되기를 바랍니다.</p>                    <ul class="bullet-list">                        <li><strong>데이터베이스를 활용한 중간 상태 저장</strong><br>여러 태스크로 구성된 <code>Taskflow</code>를 개발하다 보면, 후반부 태스크에서 API 호출 실패, MCP 서버 버그, 프롬프트 관련 문제, 토큰 또는 쿼터 문제와 같은 다양한 문제가 발생할 수 있습니다. 각 태스크의 결과를 데이터베이스에 저장함으로써, 실패 발생 시 길고 반복적인 태스크를 다시 실행하는 것을 피할 수 있습니다. 이는 시간을 절약할 뿐만 아니라, 각 태스크의 효과를 격리하고 이전 태스크에서 생성된 데이터베이스를 시작점으로 사용하여 각 태스크를 미세 조정하는 데 도움이 됩니다.</li>                        <li><strong>복잡한 태스크를 더 작은 태스크로 분해하기</strong><br>분류 <code>Taskflow</code>를 개발할 때 사용했던 모델들은 큰 컨텍스트와 복잡한 태스크를 잘 처리하지 못했습니다. 동일한 컨텍스트 내에서 복잡하고 여러 태스크를 수행하려고 하면, 태스크가 건너뛰거나 지시가 제대로 따르지 않는 문제가 자주 발생했습니다. 이를 해결하기 위해 태스크를 더 작고 독립적인 태스크로 나누고, 각 태스크는 새로운 컨텍스트로 시작했습니다. 이는 컨텍스트 윈도우 크기를 줄이고 발생했던 많은 문제를 완화하는 데 도움이 되었습니다.</li>                    </ul>                    <div class="image-box">                        <img src="https://github.blog/wp-content/uploads/2026/01/7-audit-results.png?resize=1024%2C414" alt="A task named “audit results” which exemplifies the “repeat prompt” feature. It depicts that by containing three boxes of the same size called 'audit result #1,' 'audit result #2,' and 'audit result n,' while between the #2 and the n box an ellipsis is displayed.">                        <p class="image-caption">그림 10. <code>repeat_prompt</code> 기능을 활용한 감사 태스크 병렬화</p>                    </div>                    <ul class="bullet-list">                        <li><strong>가능한 한 MCP 서버에 위임</strong><br>초기에는 워크플로우 트리거와 같은 정보를 소스 코드에서 확인하고 수집하는 작업을 프롬프트에 포함시켰습니다. LLM이 소스 코드에서 정보를 수집할 수 있을 것이라고 생각했기 때문이죠. 대부분의 경우 작동했지만, LLM의 비결정적 특성으로 인해 일부 불일치가 발생했습니다. 이러한 정보 확인 및 수집은 프로그래밍 방식으로 쉽게 수행할 수 있으므로, 정보 수집 및 확인을 위한 MCP 서버 도구를 생성했습니다. 이는 훨씬 더 일관된 결과를 가져왔습니다.</li>                        <li><strong>재사용 가능한 <code>Taskflow</code>로 여러 <code>Taskflow</code>에 조정 적용</strong><br>분류 <code>Taskflow</code>를 개발하면서 많은 태스크가 다른 분류 <code>Taskflow</code> 간에 공유될 수 있다는 것을 깨달았습니다. 한 <code>Taskflow</code>의 조정 사항을 나머지 <code>Taskflow</code>에 적용하고 복사-붙여넣기 양을 줄이기 위해, <code>Taskflow</code>를 리팩토링하고 재사용 가능한 구성 요소를 추출할 방법이 필요했습니다. 우리는 <a href="https://github.com/GitHubSecurityLab/seclab-taskflow-agent/blob/v0.0.9/doc/GRAMMAR.md#reusable-tasks">재사용 가능한 태스크</a>와 <a href="https://github.com/GitHubSecurityLab/seclab-taskflow-agent/blob/v0.0.9/README.md#prompts">프롬프트</a>와 같은 기능을 추가했습니다. 이러한 기능을 사용하여 여러 <code>Taskflow</code>에 걸쳐 변경 사항을 일관되게 재사용하고 적용할 수 있었습니다.</li>                        <li><strong>여러 <code>Taskflow</code>에 걸친 모델 구성</strong><br>LLM은 지속적으로 발전하고 새로운 버전이 자주 출시되므로, 여러 <code>Taskflow</code>에 걸쳐 모델 버전 번호를 업데이트할 방법이 필요하다는 것이 곧 분명해졌습니다. 그래서 <a href="https://github.com/GitHubSecurityLab/seclab-taskflow-agent/blob/main/README.md#model-configs">모델 구성 기능</a>을 추가하여 여러 <code>Taskflow</code>에 걸쳐 모델을 변경할 수 있도록 했으며, 이는 모델 버전 업데이트가 필요하거나 다른 모델로 <code>Taskflow</code>를 실험하고 다시 실행하려는 경우에 유용합니다.</li>                    </ul>                </div>            </div>                        <!-- CTA -->            <div class="cta-box">                <h3>실전 적용 인사이트</h3>                <p>GitHub Security Lab의 <code>Taskflow Agent</code>는 반복적인 보안 알림 분류 작업을 LLM 기반으로 혁신했습니다. 작은 태스크와 MCP 서버의 협업으로 오탐을 획기적으로 줄이고, CodeQL에서 놓쳤던 <strong>30개 이상의 실제 취약점</strong>을 발견했죠. 이제 오픈소스 프레임워크를 통해 여러분도 자신만의 자동화된 보안 워크플로우를 구축할 수 있습니다.</p>                <a href="https://github.blog/security/community-powered-security-with-ai-an-open-source-framework-for-security-research/" class="cta-button" target="_blank">Taskflow Agent 설정 가이드 보기 →</a>            </div>        </div>                <!-- 푸터 -->        <div class="footer">            <p><strong>핵심 요약</strong>: GitHub Security Lab은 <code>Taskflow Agent</code>와 LLM을 활용해 보안 알림 분류를 자동화하고 30개 이상의 실제 취약점을 발견하며, 개발자들이 겪는 오탐 분류의 비효율성을 해소했습니다.</p>            <p>출처: <a href="https://github.blog/security/ai-supported-vulnerability-triage-with-the-github-security-lab-taskflow-agent/" target="_blank">AI-supported vulnerability triage with the GitHub Security Lab Taskflow Agent</a></p>        </div>    </div></body></html>```