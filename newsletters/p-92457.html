<!DOCTYPE html><html lang="ko"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>GitHub Copilot이 도구는 줄이고 더 스마트해진 비결</title>    <link rel="preconnect" href="https://fonts.googleapis.com">    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>    <link href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600;9..144,700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">    <style>        @import url("https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable-dynamic-subset.min.css");                * {            margin: 0;            padding: 0;            box-sizing: border-box;        }                body {            font-family: "Pretendard Variable", -apple-system, BlinkMacSystemFont, system-ui, sans-serif;            background: #faf8f5;            color: #2d2d2d;            line-height: 1.7;            padding: 20px;            font-size: 16px;        }                .container {            max-width: 850px;            margin: 0 auto;            background: #ffffff;            border-radius: 16px;            overflow: hidden;            box-shadow: 0 4px 20px rgba(110, 64, 201, 0.08);            animation: fade-in 0.6s ease;        }                @keyframes fade-in {            from {                opacity: 0;                transform: translateY(20px);            }            to {                opacity: 1;                transform: translateY(0);            }        }                .header {            background: linear-gradient(135deg, #6e40c9 0%, #8a41c9 100%);            padding: 48px 40px;            color: #ffffff;        }                .header-label {            font-family: 'JetBrains Mono', monospace;            font-size: 13px;            letter-spacing: 1.5px;            opacity: 0.9;            margin-bottom: 12px;            text-transform: uppercase;        }                .header h1 {            font-family: 'Fraunces', serif;            font-size: 36px;            font-weight: 700;            line-height: 1.3;            margin-bottom: 16px;        }                .header-meta {            font-size: 14px;            opacity: 0.85;            font-weight: 500;        }                .content {            padding: 48px 40px;        }                .intro {            font-size: 18px;            line-height: 1.8;            color: #3d3d3d;            margin-bottom: 40px;            padding-bottom: 32px;            border-bottom: 2px solid #f0ebe5;            animation: fade-slide-up 0.6s ease 0.2s both;        }                .intro p {            margin-bottom: 16px;        }                .intro p:last-child {            margin-bottom: 0;        }                .intro strong {            color: #6e40c9;            font-weight: 600;        }                .intro ul {            list-style: none;            padding-left: 0;            margin: 20px 0;        }                .intro ul li {            padding-left: 28px;            margin-bottom: 10px;            position: relative;            line-height: 1.7;        }                .intro ul li::before {            content: "•";            position: absolute;            left: 0;            color: #6e40c9;            font-weight: 600;            font-size: 20px;        }                @keyframes fade-slide-up {            from {                opacity: 0;                transform: translateY(20px);            }            to {                opacity: 1;                transform: translateY(0);            }        }                .section {            margin-bottom: 40px;            animation: fade-slide-up 0.6s ease both;        }                .section:nth-child(2) { animation-delay: 0.3s; }        .section:nth-child(3) { animation-delay: 0.4s; }        .section:nth-child(4) { animation-delay: 0.5s; }        .section:nth-child(5) { animation-delay: 0.6s; }        .section:nth-child(6) { animation-delay: 0.7s; }                .section-title {            font-family: 'Fraunces', serif;            font-size: 24px;            font-weight: 700;            color: #6e40c9;            margin-bottom: 20px;            display: flex;            align-items: center;            gap: 12px;        }                .section-emoji {            font-size: 28px;        }                .section-content {            font-size: 16px;            line-height: 1.8;            color: #3d3d3d;        }                .section-content p {            margin-bottom: 16px;        }                .section-content p:last-child {            margin-bottom: 0;        }                .highlight-box {            background: #fdf9ff; /* Adjusted from #f0fff8 to a purple tint */            border-left: 4px solid #6e40c9;            padding: 20px 24px;            margin: 20px 0;            border-radius: 0 8px 8px 0;        }                .highlight-box p {            margin-bottom: 12px;            font-size: 15px;        }                .highlight-box p:last-child {            margin-bottom: 0;        }                .highlight-box strong {            color: #6e40c9;        }                .code-box {            background: #2d2d2d;            color: #f0ebe5;            padding: 20px 24px;            border-radius: 8px;            font-family: 'JetBrains Mono', monospace;            font-size: 13px;            line-height: 1.6;            margin: 20px 0;            overflow-x: auto;        }                .code-box code {            color: #6dd4c4;        }                .phase-box {            background: #ffffff;            border: 2px solid #6e40c9;            padding: 24px;            margin: 20px 0;            border-radius: 12px;        }                .phase-title {            font-family: 'Fraunces', serif;            font-size: 20px;            font-weight: 700;            color: #6e40c9;            margin-bottom: 16px;            display: flex;            align-items: center;            gap: 10px;        }                .phase-content {            font-size: 15px;            line-height: 1.7;            color: #3d3d3d;        }                .phase-content p {            margin-bottom: 12px;        }                .phase-content p:last-child {            margin-bottom: 0;        }                .metric-grid {            display: grid;            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));            gap: 16px;            margin: 24px 0;        }                .metric-card {            background: #faf8f5;            padding: 20px;            border-radius: 12px;            border: 1px solid #f0ebe5;            transition: all 0.3s ease;        }                .metric-card:hover {            transform: translateY(-4px);            box-shadow: 0 6px 20px rgba(110, 64, 201, 0.12);        }                .metric-label {            font-family: 'JetBrains Mono', monospace;            font-size: 12px;            color: #8d6e5f;            margin-bottom: 8px;            text-transform: uppercase;            letter-spacing: 0.5px;        }                .metric-value {            font-family: 'Fraunces', serif;            font-size: 28px;            font-weight: 700;            color: #6e40c9;            margin-bottom: 8px;        }                .metric-desc {            font-size: 14px;            color: #5d5d5d;            line-height: 1.5;        }                .bullet-list {            list-style: none;            padding-left: 0;            margin: 16px 0;        }                .bullet-list li {            padding-left: 32px;            margin-bottom: 12px;            position: relative;            line-height: 1.7;        }                .bullet-list li::before {            content: "→";            position: absolute;            left: 0;            color: #6e40c9;            font-weight: 600;            font-size: 18px;        }                .stage-grid {            display: grid;            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));            gap: 12px;            margin: 24px 0;        }                .stage-card {            background: #fdf9ff; /* Adjusted to purple tint */            border: 1px solid #6e40c9;            padding: 16px;            border-radius: 8px;            text-align: center;        }                .stage-number {            font-family: 'Fraunces', serif;            font-size: 32px;            font-weight: 700;            color: #6e40c9;            margin-bottom: 8px;        }                .stage-name {            font-weight: 700;            color: #2d2d2d;            margin-bottom: 8px;            font-size: 14px;        }                .stage-desc {            font-size: 12px;            color: #5d5d5d;            line-height: 1.5;        }                .cta-box {            background: linear-gradient(135deg, #6e40c9 0%, #8a41c9 100%);            color: #ffffff;            padding: 32px;            border-radius: 12px;            margin-top: 40px;            text-align: center;        }                .cta-box h3 {            font-family: 'Fraunces', serif;            font-size: 22px;            margin-bottom: 16px;        }                .cta-box p {            font-size: 15px;            line-height: 1.7;            opacity: 0.95;            margin-bottom: 20px;        }                .cta-button {            display: inline-block;            background: #ffffff;            color: #6e40c9;            padding: 14px 32px;            border-radius: 8px;            text-decoration: none;            font-weight: 600;            font-size: 15px;            transition: all 0.3s ease;        }                .cta-button:hover {            transform: translateY(-2px);            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);        }                .footer {            background: #faf8f5;            padding: 32px 40px;            text-align: center;            font-size: 14px;            color: #8d6e5f;            border-top: 1px solid #f0ebe5;        }                .footer p {            margin-bottom: 8px;        }                .footer a {            color: #6e40c9;            text-decoration: none;            font-weight: 600;        }                .footer a:hover {            text-decoration: underline;        }                @media (max-width: 768px) {            body {                padding: 12px;            }                        .header {                padding: 32px 24px;            }                        .header h1 {                font-size: 28px;            }                        .content {                padding: 32px 24px;            }                        .intro {                font-size: 16px;            }                        .section-title {                font-size: 20px;            }                        .metric-grid, .stage-grid {                grid-template-columns: 1fr;            }                        .footer {                padding: 24px;            }        }    </style></head><body>    <div class="container">        <!-- 헤더 -->        <div class="header">            <div class="header-label">GitHub Blog</div>            <h1>GitHub Copilot이 도구는 줄이고 더 스마트해진 비결</h1>            <div class="header-meta">응답 속도 400ms 단축, 도구 성공률 94.5% 달성</div>        </div>                <div class="content">            <!-- 도입부 -->            <div class="intro">                <p>요즘 VS Code에서 GitHub Copilot Chat을 쓰다가 ‘Optimizing tool selection...’ 스피너를 본 적 있으신가요? 수많은 코드를 분석하고 Azure 유틸리티까지 넘나들며 개발을 돕는 Copilot Chat이 때로는 <stronG>생각보다 느리게 느껴지는 순간</stronG>이 있죠. 에이전트에게 너무 많은 도구를 주면 오히려 느려진다는, 언뜻 역설적으로 들리는 현상입니다.</p>                                <p>이런 현상이 생기는 이유는 LLM이 수백 개의 도구 사이에서 최적의 선택을 내리는 데 <stronG>불필요한 탐색</stronG>을 거치거나, 심지어 <stronG>API 한계</stronG>에 부딪히기 때문입니다. 즉, 도구가 많아질수록 똑똑해지기보다 버벅거리는 셈이죠. 이는 개발자의 생산성을 떨어뜨리고 불필요한 대기 시간을 만듭니다.</p>                                <p>이 글에서는 GitHub Copilot이 어떻게 도구를 줄이고도 더 똑똑하고 빨라질 수 있었는지, 그 뒤에 숨겨진 흥미로운 기술적 혁신들을 정리해 봅니다. 특히 다음 내용을 중심으로 살펴볼 거예요:</p>                                <ul>                    <li><strong>너무 많은 도구가 오히려 독이 되는 이유</strong> – Copilot Chat이 겪던 성능 문제와 근본 원인</li>                    <li><strong>'가상 도구'로 수백 개 도구 관리하기</strong> – 임베딩 기반 클러스터링으로 도구 폭증 해결</li>                    <li><strong>쿼리만으로 필요한 도구 예측하기</strong> – 임베딩 기반 라우팅으로 불필요한 탐색 제거</li>                    <li><strong>핵심 도구 13개만 남긴 이유</strong> – 축소된 도구 세트가 가져온 응답 속도 및 정확도 향상</li>                    <li><strong>도구 선택을 넘어선 미래</strong> – 장기 컨텍스트 추론으로 나아가는 에이전트의 진화</li>                </ul>            </div>                        <!-- 본문 섹션 1 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">🤯</span>                    너무 많은 도구가 에이전트를 느리게 하는 이유                </h2>                <div class="section-content">                    <p>VS Code용 GitHub Copilot Chat의 기본 도구 세트에는 약 40개의 내장 도구가 있습니다. 여기에 <stronG>Model Context Protocol (MCP)</stronG> 서버까지 포함하면 그 숫자는 수백 개로 불어나죠. 문제는 이 많은 도구가 때로는 모델의 API 한계를 넘어설 수 있다는 겁니다.</p>                                        <p>수백 개의 도구 중 사용자의 쿼리에 가장 적합한 도구를 찾는 건 마치 <stronG>수많은 책 더미에서 단 하나의 문장을 찾는 것</stronG>과 같아요. 모델은 모든 도구를 일일이 탐색하며 불필요한 추론에 시간을 낭비하게 됩니다. 이 과정에서 우리는 두 가지 큰 문제에 직면했습니다.</p>                    <div class="highlight-box">                        <p><strong>1. 모델의 추론 능력 저하</strong></p>                        <p>너무 많은 도구는 모델의 <stronG>인지 부하</stronG>를 높여 핵심 작업을 놓치거나 엉뚱한 도구를 사용하는 경우가 생깁니다. 이는 사용자의 명시적인 지시를 무시하거나 불필요한 도구를 호출하는 행동으로 이어지곤 합니다.</p>                    </div>                    <div class="highlight-box">                        <p><strong>2. 응답 지연 시간(Latency) 증가</strong></p>                        <p>각 도구 선택 과정이 추가적인 왕복 통신(round trip)을 발생시키고 캐시 미스(cache miss)를 유발합니다. 사용자가 체감하는 Copilot Chat의 응답 속도가 느려지는 주된 원인이었죠.</p>                    </div>                </div>            </div>                        <!-- 본문 섹션 2 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">📦</span>                    '가상 도구'와 임베딩 기반 클러스터링으로 도구 폭증 해결                </h2>                <div class="section-content">                    <p>이 문제를 해결하기 위해 GitHub 팀은 <stronG>“가상 도구(Virtual Tools)”</stronG>라는 개념을 도입했습니다. 기능적으로 유사한 도구들을 하나의 가상 도구 아래 묶어서, 모델은 전체 도구에 대한 개괄적인 정보만 보게 됩니다. 마치 폴더 안에 여러 파일이 있는 것처럼요. 이는 모델이 수백 개의 도구 이름을 모두 외울 필요 없이, <stronG>필요할 때만 해당 그룹을 확장</stronG>하여 세부 도구를 탐색하도록 돕습니다.</p>                    <p>하지만 단순히 그룹화하는 것만으로는 부족합니다. 그룹 자체를 어떻게 효율적으로 만들고 관리할지가 관건이었죠. 초기에는 LLM에게 직접 도구들을 그룹화하고 요약해달라고 요청했지만, 몇 가지 한계에 부딪혔습니다.</p>                    <div class="highlight-box">                        <p><strong>LLM 기반 클러스터링의 한계</strong></p>                        <p>생성되는 그룹 수를 제어하기 어렵고, 모델의 API 한계를 초과하는 경우가 잦았습니다. 또한, 매우 느리고 토큰 비용이 많이 들었으며, 가끔 특정 도구를 누락하는 문제도 있었죠.</p>                    </div>                    <p>이 문제를 해결하기 위해, 우리는 <stronG>‘적응형 도구 클러스터링(Adaptive Tool Clustering)’</stronG> 시스템을 개발했습니다. 핵심은 Copilot의 내부 임베딩 모델을 활용하는 것입니다. 이 모델은 각 도구의 임베딩을 생성하고, <stronG>코사인 유사도</stronG>를 기반으로 도구들을 정확하고 안정적으로 그룹화합니다. 이렇게 만들어진 그룹들은 요약 단계에서만 LLM을 활용하며, 임베딩과 요약 결과는 로컬에 캐싱되어 효율성을 극대화합니다.</p>                </div>            </div>                        <!-- 본문 섹션 3 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">🧭</span>                    컨텍스트 인지형 임베딩 라우팅으로 불필요한 탐색 줄이기                </h2>                <div class="section-content">                    <p>도구들을 그룹화한 후에도 또 다른 과제가 남아있었습니다. 모델이 어떤 가상 도구 그룹을 열어야 할지 어떻게 알 수 있을까요? 모델은 결국 올바른 도구를 찾아내지만, 그 과정에서 <stronG>불필요한 탐색과 여러 차례의 호출(round trip)</stronG>을 거치곤 했습니다. 예를 들어, 사용자가 버그를 수정하고 개발 브랜치에 병합하라고 지시했을 때, 모델은 검색 도구, 문서 도구, 로컬 Git 도구 등을 불필요하게 탐색하다가 결국 GitHub MCP 그룹 내의 병합 도구가 필요하다는 것을 깨닫는 식이죠.</p>                                        <p>이러한 비효율을 제거하기 위해 우리는 <stronG>‘임베딩 기반 도구 라우팅(Embedding-Guided Tool Routing)’</stronG>을 도입했습니다. 이 시스템은 어떤 도구 그룹이 확장되기 전에, 사용자 쿼리의 임베딩을 모든 도구(및 클러스터)의 벡터 표현과 비교합니다. 이를 통해 <stronG>가장 의미론적으로 관련성 높은 후보 도구</stronG>를 사전에 선택할 수 있습니다.</p>                    <div class="highlight-box">                        <p><strong>어떻게 작동하나요?</strong></p>                        <p>사용자 쿼리가 들어오면, 시스템은 즉시 <stronG>쿼리 임베딩</stronG>을 생성합니다. 그리고 이 임베딩을 모든 도구와 도구 클러스터의 임베딩과 비교하여 가장 유사한 것들을 찾아냅니다. 예를 들어, "버그 수정 후 개발 브랜치에 병합"이라는 쿼리에서, 시스템은 처음부터 '병합 도구'가 필요할 가능성이 높다는 것을 추론하여 이를 후보군에 포함시키는 거죠. 이는 <stronG>불필요한 탐색 호출(exploratory calls)을 제거</stronG>하여 지연 시간을 크게 줄이고 실패율을 낮춥니다.</p>                    </div>                    <p>이 임베딩 기반 접근 방식의 효과는 <stronG>Tool Use Coverage</stronG> 지표로 측정했습니다. 이는 모델이 필요할 때 올바른 도구를 얼마나 자주 가시적으로 가지고 있는지를 나타냅니다. 결과는 놀라웠습니다.</p>                    <div class="metric-grid">                        <div class="metric-card">                            <div class="metric-label">Embedding Based</div>                            <div class="metric-value">94.5%</div>                            <div class="metric-desc">최적의 도구 가시성 달성</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">LLM Based</div>                            <div class="metric-value">87.5%</div>                            <div class="metric-desc">기존 LLM 방식 대비 +7%p</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">Default Tools</div>                            <div class="metric-value">69.0%</div>                            <div class="metric-desc">정적 도구 목록 대비 +25.5%p</div>                        </div>                    </div>                    <p>오프라인 벤치마크에서 임베딩 기반 접근 방식은 기존 LLM 기반 방식 대비 <stronG>27.5%p의 절대적인 커버리지 개선</stronG>을 보였습니다. 온라인 테스트에서도 이 추세는 그대로 이어져, 기존 방식으로는 19%에 불과했던 사전 확장 성공률이 임베딩 기반 방식에서는 <stronG>72%</stronG>로 크게 향상되었습니다. 이는 실제 사용 환경에서도 동일한 이점이 있음을 확인시켜 줍니다.</p>                </div>            </div>                        <!-- 본문 섹션 4 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">🚀</span>                    핵심 도구 13개만 남긴 이유: 더 빠른 응답과 정확도                </h2>                <div class="section-content">                    <p>수백 개의 MCP 서버 도구는 차치하고라도, 너무 많은 내장 도구 세트 역시 성능을 저하시킨다는 것을 발견했습니다. 오프라인 벤치마크(SWE-Lancer 포함)에서 에이전트가 전체 내장 도구 세트에 접근할 수 있을 때, 문제 해결 성공률이 <stronG>2~5%p 감소</stronG>하는 현상을 관찰했습니다.</p>                                        <p>도구 사용 통계와 성능 데이터를 기반으로, 우리는 <stronG>13개의 필수 핵심 도구</stronG>만 남기기로 결정했습니다. 이 핵심 도구들은 고수준의 저장소 구조 분석, 파일 읽기/편집, 컨텍스트 검색, 터미널 사용 등 가장 기본적인 기능들을 포괄합니다. 나머지 비핵심 내장 도구들은 Jupyter Notebook, Web Interaction, VS Code Workspace, Testing이라는 4가지 가상 카테고리로 묶었습니다. 이렇게 하면 모델은 처음에는 작은 핵심 세트만 보고, 필요할 때만 그룹을 확장하게 됩니다.</p>                    <p>결과는 매우 긍정적이었습니다. 축소된 도구 세트를 사용하는 사용자들은 평균적으로 <stronG>TTFT (Time To First Token)가 190밀리초, TTFT (Time To Final Token, 응답 완료 시간)가 400밀리초 감소</stronG>하는 것을 경험했습니다.</p>                    <div class="metric-grid">                        <div class="metric-card">                            <div class="metric-label">Latency Decrease (Avg.)</div>                            <div class="metric-value">400ms</div>                            <div class="metric-desc">온라인 A/B 테스트에서 응답 시간 단축</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">Success Rate Boost</div>                            <div class="metric-value">+2-5pp</div>                            <div class="metric-desc">SWE-Lancer 벤치마크에서 성공률 증가</div>                        </div>                        <div class="metric-card">                            <div class="metric-label">Core Tools Count</div>                            <div class="metric-value">13</div>                            <div class="metric-desc">기존 40개에서 13개로 축소</div>                        </div>                    </div>                    <p>더 적은 도구 세트는 에이전트의 효율성을 높여 <stronG>더 단순한 추론, 더 빠른 응답 시간, 그리고 더 나은 성능</stronG>으로 이어집니다. '덜어내는 것이 더하는 것'이라는 원칙이 Copilot Chat에도 적용된 셈이죠.</p>                </div>            </div>                        <!-- 본문 섹션 5 -->            <div class="section">                <h2 class="section-title">                    <span class="section-emoji">🔭</span>                    도구 선택을 넘어선 미래: 장기 컨텍스트 추론으로                </h2>                <div class="section-content">                    <p>MCP 시스템이 발전함에 따라, 단순히 올바른 도구를 선택하는 것을 넘어 <stronG>시간, 컨텍스트, 상호작용 전반에 걸쳐 추론</stronG>하는 것이 중요해지고 있습니다.</p>                                        <p>진정으로 지능적인 모델이라면 단순히 쿼리에 반응하는 것을 넘어, <stronG>이전 도구 사용 기록을 기억하고, 히스토리에서 의도를 추론하며, 여러 단계의 액션(multi-step actions)을 계획</stronG>할 수 있어야 합니다. 이러한 관점에서 보면, 현재의 도구 선택 과정은 <stronG>장기 컨텍스트 추론</stronG>의 초기 형태라고 볼 수 있습니다. 현재 모델이 올바른 도구로 경로를 설정하도록 돕는 메커니즘이 미래에는 수천 번의 턴(turns)에 걸쳐 추론하며, 언제 행동하고, 언제 위임하고, 언제 멈춰야 할지 결정하는 데 도움을 줄 수 있을 겁니다.</p>                                        <p>GitHub의 다음 단계는 임베딩, 메모리, 그리고 강화 신호(reinforcement signals)를 어떻게 결합하여 단순히 <stronG>‘어떤 도구를 선택할지’</stronG>를 넘어 <stronG>‘도구를 어떻게 사용할지’</stronG>까지 학습하는 컨텍스트 인식 에이전트를 만들지 탐색하는 것입니다. 이는 개발자의 코딩 경험을 한 단계 더 진화시킬 잠재력을 가지고 있습니다.</p>                </div>            </div>                        <!-- CTA -->            <div class="cta-box">                <h3>GitHub Copilot, 이제 더 똑똑하게 일해요</h3>                <p>GitHub Copilot은 단순한 코드 도우미를 넘어, 최적화된 도구 선택과 컨텍스트 인지 능력으로 개발 흐름을 혁신합니다. 불필요한 탐색은 줄이고, 핵심 작업에 집중할 수 있도록 돕습니다. 원문에서 더 자세한 기술 인사이트를 확인해 보세요!</p>                <a href="https://github.blog/ai-and-ml/github-copilot/how-were-making-github-copilot-smarter-with-fewer-tools/" class="cta-button" target="_blank">원문 읽기 →</a>            </div>        </div>                <!-- 푸터 -->        <div class="footer">            <p><strong>핵심 요약</strong>: GitHub Copilot은 임베딩 기반 도구 라우팅, 적응형 클러스터링, 그리고 13개의 핵심 도구 세트 최적화를 통해 응답 속도를 400ms 단축하고 도구 활용 정확도를 94.5%까지 높였습니다.</p>            <p>출처: <a href="https://github.blog/ai-and-ml/github-copilot/how-were-making-github-copilot-smarter-with-fewer-tools/" target="_blank">GitHub Blog: How we’re making GitHub Copilot smarter with fewer tools</a></p>        </div>    </div></body></html>```